# Props
## Receiving state from parent component
Another way to get application data into a component is by Props.

Props is the data which is passed to the child component from the parent component. This allows for our React architecture to stay pretty straight forward. Handle state in the highest most parent component which needs to use the specific data, and if you have a child component that also needs that data, pass that data down as props.

Here’s a very basic example of using props:

    // helloWorld.js
    class HelloWorld extends React.Component{
        render() {
            return (
                <div>
                    <h1>Hello {this.props.name}</h1>
                </div>
            )
        }
    };

    ReactDOM.render(<HelloWorld name="Euricom" />, document.getElementById('app'));

Notice in our ReactDOM.render we have an attribute called name with a value of "Euricom". Now in our component, we can use {this.props.name} to get "Euricom".

Another way to pass props is by transclusion, or in other words, as element content:

    class HelloWorld extends React.Component{
        render() {
            return (
                <div>
                    <h1>{this.props.children}</h1>
                </div>
            )
        }
    };

    ReactDOM.render(<HelloWorld>Hello children</HelloWorld>, document.getElementById('app'));

We get a hold of the parent his content by *this.props.children*.

Let’s look at a more advanced example. We’re going to have two components now. One parent, one child. The parent is going to keep track of the state and pass a part of that state down to the child as props.

Let’s first take a look at that parent component:

    // app.js
    class EmployeeContainer extends React.Component{
        constructor(props) {
            super(props);
            this.state = {
                company: 'Euricom',
                employees: ['Peter', 'Niels', 'Kevin']
            }
        }

        render() {
            return (
                <div>
                    <h1>{this.state.company}</h1>
                    <EmployeeList employees={this.state.employees}/>
                </div>
            )
        }
    }

There really isn’t much going on in this component that we haven’t seen before. We have an initial state and we pass part of that initial state to another component.

The majority of the new code will come from this child component so let’s take a closer look at that:

    // app.js
    class EmployeeList extends React.Component{
        render() {
            return (
                <div>
                    <h3>Employees</h3>
                    <ul>
                        {this._renderItems()}
                    </ul>
                </div>
            )
        }

        _renderItems() {
            return this.props.employees.map((employee) => {
                return <li>{employee}</li>
            })
        }
    }

In our child component we want to print out the list of employees which we passed down from our parent component.

We want to print these out as an unordered list (ul) so we need to convert the array of strings to an array of list items (li). For this process we are going to create a function (renderItems) which will handle this for us.

If you’re not familiar with Array.prototype.map, this code might look a little weird. All map does is it creates a new array, calls our callback function on each item in the array, and fills the new array with the result of calling the callback function on each item.

In this case we will loop over every string in our array and transform them to list items.

The result of our map function will return the following:

    ["<li>Peter</li>", "<li>Niels</li>", "<li>Kevin</li>"];

Finally we call our renderItems function in our render (by surrounding it with { }) to fill our < ul > with the list items.

### Key
When we take a look at our console, we notice this warning:

    Warning: Each child in an array or iterator should have a unique "key" prop. Check the render method of EmployeeList. See https://fb.me/react-warning-keys for more information.

The warning gives us a good description on why it's being thrown. When rendering items from an array we should add a (unique - inside the rendered collection) key attribute.

Think of the *key* property as a unique identifier for the components being returned from *map*.

Key point:

    When React reconciles the keyed children, it will ensure that any child with key will be reordered (instead of clobbered) or destroyed (instead of reused).

When we take a look at the rendered elements in our dev tools:

<img src="images/reactBeforeKey.png" alt="">

Let's review our EmployeeList component:

    class EmployeeList extends React.Component{
        render() {
            return (
                <div>
                    <h3>Employees</h3>
                    <ul>
                        {this._renderItems()}
                    </ul>
                </div>
            )
        }

        _renderItems() {
            return this.props.employees.map((employee, index) => {
                return <li key={index}>{employee}</li>
            })
        }
    }

We can use the second argument from our map function (index) to use as our key.

The *data-reactid* of our rendered elements have been edited, notice the addition of **$**:

<img src="images/reactAfterKey.png" alt="">

## Receiving functionality from parent component
It’s important to understand that wherever the data lives, is the exact place you want to manipulate that data. This keeps it simple to reason about your data. All getter/setter methods for a certain piece of data will always be in the same component where that data was defined.

If you needed to manipulate some piece of data outside where the data lives, you’d pass the getter/setter method into that component as props. Let’s take a look at an example like that.

We're going to add a new component (AddNewEmployee) to our previous example. We'll render an input box and a button so we can add a new employee to our list.

    class AddEmployee extends React.Component{
        render() {
            return (
                <div>
                    <div>Add new employee</div>
                    <input  type="text"
                            value={this.props.newEmployee}
                            onChange={(e) => this.props.onHandleChangeEmployee(e)}/>
                    <button onClick={() => this.props.addNewEmployee()}>add new</button>
                </div>
            )
        }
    }

If we take a look at our new component, we can see that it doesn't do much besides rendering some HTML.

All the logic is being passed by our parent (EmployeeContainer) component. Since our parent holds our state, we'll also put all the logic that can manipulate our state there.

Our updated parent component (EmployeeContainer):

    class EmployeeContainer extends React.Component{
        constructor(props) {
            super(props);
            this.state = {
                company: 'Euricom',
                employees: ['Peter', 'Niels', 'Kevin'],
                newEmployee: ''
            }
        }

        render() {
            return (
                <div>
                    <h1>{this.state.company}</h1>
                        <AddEmployee    newEmployee={this.state.newEmployee}
                                        onHandleChangeEmployee={(e) => this._onHandleChangeEmployee(e)}
                                        addNewEmployee={(newEmployee) => this._addNewEmployee(newEmployee)} />
                    <EmployeeList employees={this.state.employees}/>
                </div>
            )
        }

        _onHandleChangeEmployee(e) {
            this.setState({
                newEmployee: e.target.value
            })
        }

        _addNewEmployee() {
            this.setState({
                employees: this.state.employees.concat(this.state.newEmployee),
                newEmployee: ''
            })
        }
    }

In the example above we've added our AddEmployee component in our render function. We pass in 3 arguments:

- **newEmployee**: a state variable which will be used as a value for our input box
- **onChange**: a function (_changeHandler) which will be used to respond on every value change in our input box. Everytime the value changes, we update the newEmployee variable (on our state).
- **addNewEmployee**: a function which will add the new employee to the list of employees on our state. We also empty our newEmployee for new input.

#### Extra example
As an extra example we could have our employees be objects and add an 'isAvailable' property.

    // employeeContainer.js
    constructor(props) {
        super(props);
        this.state = {
            company: 'Euricom',
            employees: [
                {name: 'Peter', isAvailable: true},
                {name: 'Niels', isAvailable: false},
                {name: 'Kevin', isAvailable: true}
            ],
            newEmployee: ''
        }
    }

Now in our employeeList we could give our employees a color which relates to his availability:

    // employeeList.js
    class EmployeeList extends React.Component{
      render() {
          return (
              <div>
                  <h3>Employees</h3>
                  <ul>
                      {this._renderItems()}
                  </ul>
              </div>
          )
      }

      _renderItems() {
          return this.props.employees.map((employee, index) => {
              return (
                <li key={index}>
                    <p style={{'color': employee.available ? 'green' : 'red'}}>{employee.name}</p>
                    </li>
              )
          })
        }
    }

Additionally we want to change the availability when clicking on an employee. For this to happen we create an extra function on our employeeContainer:

    // employeeContainer.js
    _toggleAvailability(employee) {
        var employees = this.state.employees;
        employees.forEach(function(emp){
            if(employee.name === emp.name) {
                employee.isAvailable = !employee.isAvailable;
            }
        })
        this.setState({
            employees: employees
        })
    }

Next we'll pass this function as a prop to our employeeList:

    render() {
        return (
            <div>
                <h1>{this.state.company}</h1>
                <AddEmployee    newEmployee={this.state.newEmployee}
                                onHandleChangeEmployee={(e) => this._onHandleChangeEmployee(e)}
                                addNewEmployee={(newEmployee) => this._addNewEmployee(newEmployee)} />
                <EmployeeList   employees={this.state.employees}
                                toggleAvailability={(employee) => this._toggleAvailability(employee)}/>
            </div>
        )
    }


Finally we make use of the passed in function in our employeeList:

    // employeeList.js
    _renderItems() {
        return this.props.employees.map((employee, index) => {
            return  <li key={index} onClick={this.props.toggleAvailability.bind(null, employee)} >
                        <p style={{'color': employee.isAvailable ? 'green' : 'red'}}>{employee.name}</p>
                    </li>
        })
    }

When testing our app we notice that we can effectively change the availability of our employees but when adding a new one there seems to be something wrong. We are adding a string into our array of employees when actually we need to provide an object:

    _addNewEmployee() {
        if (this._isInputValid()) {
                this.setState({
                employees: this.state.employees.concat({name: this.state.newEmployee, isAvailable: true}),
                newEmployee: ''
            })
        }
    }

**EXERCISE**
[Complete exercise 1](https://github.com/Euricom/frontend-bootcamp-2016Q1/blob/master/topics/8.%20react-and-flux/exercises/Chapter%201%20The%20basics/exercise.md#exercises)

## Proptypes
As your app grows it's helpful to ensure that your components are used correctly. We do this by allowing you to specify propTypes. React.PropTypes exports a range of validators that can be used to make sure the data you receive is valid. When an invalid value is provided for a prop, a warning will be shown in the console.

propTypes allow you to control the presence, or types of certain props passed to the child component. With propTypes you can specify that certain props are required or that certain props be a specific type.

    class AddEmployee extends React.Component{
        render() {
            return (
                <div>
                    <div>Add new employee</div>
                    <input  type="text"
                            value={this.props.newEmployee}
                            onChange={(e) => this.props.onHandleChangeEmployee(e)}/>
                    <button onClick={() => this.props.addNewEmployee()}>add new</button>
                </div>
            )
        }
    }

    AddEmployee.propTypes = {
        newEmployee: React.PropTypes.string.isRequired,
        onChange: React.PropTypes.func.isRequired,
        addNewEmployee: React.PropTypes.func.isRequired
    }

In the example above we define all our props with their type. Notice we can specify if a prop is required or not. If a required prop is not passed by it's parent or if it's not a function a warning will be thrown:

    Warning: Failed propType: Required prop `addNew` was not specified in `AddEmployee`. Check the render method of `EmployeeContainer`.

But even if a prop is not required, a warning will always be thrown if the expected prop has a different type than defined:

    Warning: Failed propType: Invalid prop `errors` of type `array` supplied to `AddEmployee`, expected `object`. Check the render method of `EmployeeContainer`.

It's recommended to always specify propTypes. It gives developers a quick overview of all used props and if they are required or not.

**EXERCISE**
[Complete exercises 2](https://github.com/Euricom/frontend-bootcamp-2016Q1/blob/master/topics/8.%20react-and-flux/exercises/Chapter%201%20The%20basics/exercise.md#exercises)

## getDefaultProps
Allows you to specify a default (or a backup) value for certain props just in case those props are never passed into the component.

    class EmployeeList extends React.Component{
        render() {
            return (
                <div>
                    <h3>Employees</h3>
                    <ul>
                        {this._renderItems()}
                    </ul>
                </div>
            )
        }

        _renderItems() {
          return this.props.employees.map((employee, index) => {
              return (
                <li key={index}>
                    <p style={{'color': employee.available ? 'green' : 'red'}}>{employee.name}</p>
                    </li>
              )
          })
        }
    }

    EmployeeList.propTypes = {
        employees: React.PropTypes.array
    }

    EmployeeList.defaultProps = {
        employees: [name: 'Wart Claes', isAvailable: true]
    };